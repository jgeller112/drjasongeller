---
title: "Analzying Pupil Labs Neon Data With GazeR"
date: 2025-10-31
description: "I demonstrate how to analyze pupil data from Pupil Labs Neon mobile eye-tracker with my eye-tracking R package gazeR."
categories:
  - r
  - pupillometry
  - statistics

format:
  html: 
    theme: dracula
    css: halloween.css
        
execute: 
  echo: true
  message: false
  warning: false
---

ðŸŽƒ Happy Halloween, goils and boils! ðŸ‘»

I have a spooktacular blog post for you todayâ€”one that dives into the mysterious world of pupil data from Pupil Labs Neon glasses. Weâ€™re currently using the Neon in the classroom to study mind wandering and attention. However, these mobile eye trackers arenâ€™t just for field studiesâ€”they shine in the lab too.

To demonstrate this, I created a simple PsychoPy experiment that interfaces seamlessly with the Neon (you can find it here: https://osf.io/txz59/overview ). In the task, participants view a bright sun for 30 seconds followed by a dark patch for another 30 seconds. The pupil responds to basic visual features like brightnessâ€”constricting in light and dilating in the dark.

![](images/Eye_dilate.gif){fig-align="center"}

In this post, Iâ€™ll show how the Neon glasses can capture these pupillary dynamics and how you can use my R package {gazeR} to preprocess pupil data collected from Pupil Labs devices.

## gazeR Pupil labs Functions

Once you collect data with Pupil Labs Neon, your recordings live in Pupil Cloud. Export the Time Series for each recording (CSV export). After the export finishes, youâ€™ll have a folder per participant/recording containing multiple CSV files.

![](images/timeseries.jpg){fig-align="center"}

From each participant folder, we use exactly three files:

gaze.csv â€” gaze samples (timestamps, x/y pixels, fixations, blinks)

3d_eye_states.csv â€” pupil diameters (left/right, in mm)

events.csv â€” experiment events/messages (e.g., trial markers)

![](images/pl_files.jpg){fig-align="center"}

I created two new functions to read and process this data from Pupil Labs:

`parse_pl()` and `process_all_subjects_PL()`. Both work in tandem to prepare Neon data for use with {gazeR}.

## What the functions do

`parse_pl(subject_dir, aoi = FALSE, start_mode = c("any","exact"), start_messages = NULL, max_event_lag_ms = 20)`

Processes one participant:

1.  Reads the three CSVs and converts timestamps to milliseconds.

2.  Joins pupil data to gaze samples.

3.  Aligns each non-recording event (events.csv) to the nearest gaze row (within max_event_lag_ms).

4.  If aoi=TRUE, it can read in the surface or AOI files. Here we used the marker mapper to map gaze on the screen of the laptop I used to record the data.

5.  Creates trial indices:

-   start_mode = "any" â†’ any non-empty message (excluding recording.begin/.end) starts a new trial.

-   start_mode = "exact" â†’ only messages listed in start_messages start a new trial (robust to case/whitespace/hyphen differences).

6.  Resets time to 0 at the first row of each trial.

7.  Returns a tidy tibble ready for {gazeR}: `subject, trial, time, x, y, pupil, blink, message.`

::: callout-note
If you read in surface data, it will include whether gaze was found on the surface or not as well as x,y surface coordinates.
:::

`process_all_subjects_PL(root_dir, output_dir = file.path(root_dir, "processed"), ...)`

Batch-processes **all** immediate subfolders of `root_dir` using `parse_pl()`, writes one CSV per subject plus a combined files

-   Per-subject files: `{output_dir}/{SUBJECT}_processed.cs`

    Combined file: `{output_dir}/all_subjects_processed.csv`

Any additional arguments (`...`) are passed straight to `parse_pl()` (e.g., `start_mode`, `start_messages`, `max_event_lag_ms`).

# Example Dataset

Let's read in the dataset created from the above functions.

We will load in {gazeR} and needed libraries.

```{r}

remotes::install_github("dmirman/gazer") # gazer package
library(gazer) # load in 
library(tidyverse) # viz
library(knitr) # tables
```

```{r}
sub_pl = read.csv("https://osf.io/zf2qu/download")
kable(head(sub_pl))
```

Let's take a look at the data we have.

```{r}
#| echo: false
interp_graph <- sub_pl |>
  dplyr::filter(trial == 2)

# Graph interpolation
pup_g <- ggplot(interp_graph, aes(x = time, y = pupil)) +
  geom_point() +
  geom_line(color = "orange", size = 1.2) +
  xlab("Time (ms)") +
  ylab("Pupil Size (mm)") +
  theme_bw() +
  theme(
    axis.title.y = element_text(size = 16, face = "bold"),
    axis.title.x = element_text(size = 16, face = "bold"),
    axis.text.x  = element_text(size = 12, face = "bold"),
    axis.text.y  = element_text(size = 12, face = "bold"),
    plot.title   = element_text(size = 18, face = "bold", hjust = 0.5)
  )

pup_g +
  theme(
    panel.background = element_rect(fill = "black"),
    plot.background = element_rect(fill = "black"),
    axis.text = element_text(color = "orange"),
    axis.title = element_text(color = "#ff7518"),
    plot.title = element_text(color = "orange", face = "bold", size = 18, hjust = 0.5)
  ) +
  geom_line(color = "#ff7518") +
  geom_point(color = "#ffcc00")
```

This is what the pupil data looks like for the entire time course.

## Extending Blinks

We see dips in the pupil signalâ€”these are most likely caused by blinks. Pupil Labs includes a blink detection algorithm, which weâ€™ll use here. We first set pupil size values corresponding to blinks to NA, then use extend_blinks()to extend blinks 100 ms forward and backward in time.

```{r}

  #Extend Blinks
pup_extend<- sub_pl |>
  mutate(pupil=ifelse(blink==TRUE, NA, pupil)) |>
  group_by(subject, trial) |>
  mutate(extendpupil=extend_blinks(pupil, fillback=100, fillforward=100, hz=200)) |>
  ungroup() 
```

## Interpolate blinks

Next, we linearly interpolate over blinks and smooth the data using a 5-point moving average.

```{r}
# Smooth and Interpolate
smooth_interp <- smooth_interpolate_pupil(pup_extend, pupil="pupil", extendpupil="extendpupil", extendblinks=TRUE, step.first="smooth", maxgap=Inf, type="linear", hz=200, n=5)
```

Then, calculate missing data and remove trials with more than 50% missing data.

```{r}
 pup_missing<-count_missing_pupil(smooth_interp, missingthresh = .5)
```

## Unlikely Pupil Sizes

Now, keep only plausible pupil diameters between 2 mm and 9 mm.

```{r}
pup_outliers<-pup_missing |>
  dplyr::filter (pup_interp  >= 2, pup_interp <= 9)
```

## MAD

Get rid of artifacts we might have missed during some earlier steps.

```{r}
  #MAD removal
max_removal<-pup_missing  |>
  dplyr::group_by(subject, trial) |>
  dplyr::mutate(speed=speed_pupil(pup_interp,time)) |>
  dplyr::mutate(MAD=calc_mad(speed)) |>
  dplyr::filter(speed < MAD)

```

## Onset

Let's only look from the start of the trial until 1000 ms

```{r}
pupil_onset<-max_removal |>
  dplyr::group_by(subject, trial) |>
  dplyr::filter(time <= 1000) |>
  select(subject, trial, time, pup_interp)
```

## Downsample

Downsample the time-course to 100 ms.

```{r}
#downsample
timebins1<- downsample_gaze(pupil_onset, bin.length=100, pupil="pup_interp", timevar = "time", aggvars = c("subject", "trial", "timebins"), type="pupil")

kable(head(timebins1))
```

## Visualize Time-course

```{r}
#| echo: false
#| fig-align: center
interp_graph <- timebins1 |>
  dplyr::filter(trial == 1)

# Graph interpolation
pup_g <- ggplot(interp_graph, aes(x = timebins, y = aggbaseline)) +
  geom_point() +
  geom_line(color = "orange", size = 1.2) +
  ggtitle("Pupil Constriction") +
  xlab("Time (ms)") +
  ylab("Pupil Size (mm)") +
  theme_bw() +
  theme(
    axis.title.y = element_text(size = 16, face = "bold"),
    axis.title.x = element_text(size = 16, face = "bold"),
    axis.text.x  = element_text(size = 12, face = "bold"),
    axis.text.y  = element_text(size = 12, face = "bold"),
    plot.title   = element_text(size = 18, face = "bold", hjust = 0.5)
  )

pup_g +
  theme(
    panel.background = element_rect(fill = "black"),
    plot.background = element_rect(fill = "black"),
    axis.text = element_text(color = "orange"),
    axis.title = element_text(color = "#ff7518"),
    plot.title = element_text(color = "orange", face = "bold", size = 18, hjust = 0.5)
  ) +
  geom_line(color = "#ff7518") +
  geom_point(color = "#ffcc00")
```

```{r}
#| echo: false
#| fig-align: center
#| 
interp_graph <- timebins1 |>
  dplyr::filter(trial == 2)

# Graph interpolation
pup_g <- ggplot(interp_graph, aes(x = timebins, y = aggbaseline)) +
  geom_point() +
  geom_line(color = "orange", size = 1.2) +
  ggtitle("Pupil Dilation") +
  xlab("Time (ms)") +
  ylab("Pupil Size (mm)") +
  theme_bw() +
  theme(
    axis.title.y = element_text(size = 16, face = "bold"),
    axis.title.x = element_text(size = 16, face = "bold"),
    axis.text.x  = element_text(size = 12, face = "bold"),
    axis.text.y  = element_text(size = 12, face = "bold"),
    plot.title   = element_text(size = 18, face = "bold", hjust = 0.5)
  )

pup_g +
  theme(
    panel.background = element_rect(fill = "black"),
    plot.background = element_rect(fill = "black"),
    axis.text = element_text(color = "orange"),
    axis.title = element_text(color = "#ff7518"),
    plot.title = element_text(color = "orange", face = "bold", size = 18, hjust = 0.5)
  ) +
  geom_line(color = "#ff7518") +
  geom_point(color = "#ffcc00")
```

# Surface Looks

What does the data look like if we constrain the analyses to only include looks to the laptop screen?

```{r}
sub_pl = read.csv("https://osf.io/enf6u/download")
kable(head(sub_pl))
```

Let's take a look at the data we have.

```{r}
#| echo: false
interp_graph <- sub_pl |>
  dplyr::filter(trial == 2)

# Graph interpolation
pup_g <- ggplot(interp_graph, aes(x = time, y = pupil)) +
  geom_point() +
  geom_line(color = "orange", size = 1.2) +
  xlab("Time (ms)") +
  ylab("Pupil Size (mm)") +
  theme_bw() +
  theme(
    axis.title.y = element_text(size = 16, face = "bold"),
    axis.title.x = element_text(size = 16, face = "bold"),
    axis.text.x  = element_text(size = 12, face = "bold"),
    axis.text.y  = element_text(size = 12, face = "bold"),
    plot.title   = element_text(size = 18, face = "bold", hjust = 0.5)
  )

pup_g +
  theme(
    panel.background = element_rect(fill = "black"),
    plot.background = element_rect(fill = "black"),
    axis.text = element_text(color = "orange"),
    axis.title = element_text(color = "#ff7518"),
    plot.title = element_text(color = "orange", face = "bold", size = 18, hjust = 0.5)
  ) +
  geom_line(color = "#ff7518") +
  geom_point(color = "#ffcc00")
```

This is what the pupil data looks like for the entire time course.

## Extending Blinks

We see dips in the pupil signalâ€”these are most likely caused by blinks. Pupil Labs includes a blink detection algorithm, which weâ€™ll use here. We first set pupil size values corresponding to blinks to NA, then use extend_blinks()to extend blinks 100 ms forward and backward in time.

```{r}

  #Extend Blinks
pup_extend<- sub_pl |>
  mutate(pupil=ifelse(blink==TRUE, NA, pupil)) |>
  group_by(subject, trial) |>
  mutate(extendpupil=extend_blinks(pupil, fillback=100, fillforward=100, hz=200)) |>
  ungroup() 
```

## Interpolate blinks

Next, we linearly interpolate over blinks and smooth the data using a 5-point moving average.

```{r}
# Smooth and Interpolate
smooth_interp <- smooth_interpolate_pupil(pup_extend, pupil="pupil", extendpupil="extendpupil", extendblinks=TRUE, step.first="smooth", maxgap=Inf, type="linear", hz=200, n=5)
```

Then, calculate missing data and remove trials with more than 50% missing data.

```{r}
 pup_missing<-count_missing_pupil(smooth_interp, missingthresh = .5)
```

## Unlikely Pupil Sizes

Now, keep only plausible pupil diameters between 2 mm and 9 mm.

```{r}
pup_outliers<-pup_missing |>
  dplyr::filter (pup_interp  >= 2, pup_interp <= 9)
```

## MAD

Get rid of artifacts we might have missed during some earlier steps.

```{r}
  #MAD removal
max_removal<-pup_missing  |>
  dplyr::group_by(subject, trial) |>
  dplyr::mutate(speed=speed_pupil(pup_interp,time)) |>
  dplyr::mutate(MAD=calc_mad(speed)) |>
  dplyr::filter(speed < MAD)

```

## Onset

Let's only look from the start of the trial until 1000 ms

```{r}
pupil_onset<-max_removal |>
  dplyr::group_by(subject, trial) |>
  dplyr::filter(time <= 1000, gaze_detected_on_surface==TRUE) |>
  select(subject, trial, time, pup_interp)
```

## Downsample

Downsample the time-course to 100 ms.

```{r}
#downsample
timebins1<- downsample_gaze(pupil_onset, bin.length=100, pupil="pup_interp", timevar = "time", aggvars = c("subject", "trial", "timebins"), type="pupil")

kable(head(timebins1))
```

## Visualize Time-course

```{r}
#| echo: false
#| fig-align: center
interp_graph <- timebins1 |>
  dplyr::filter(trial == 1)

# Graph interpolation
pup_g <- ggplot(interp_graph, aes(x = timebins, y = aggbaseline)) +
  geom_point() +
  geom_line(color = "orange", size = 1.2) +
  ggtitle("Pupil Constriction") +
  xlab("Time (ms)") +
  ylab("Pupil Size (mm)") +
  theme_bw() +
  theme(
    axis.title.y = element_text(size = 16, face = "bold"),
    axis.title.x = element_text(size = 16, face = "bold"),
    axis.text.x  = element_text(size = 12, face = "bold"),
    axis.text.y  = element_text(size = 12, face = "bold"),
    plot.title   = element_text(size = 18, face = "bold", hjust = 0.5)
  )

pup_g +
  theme(
    panel.background = element_rect(fill = "black"),
    plot.background = element_rect(fill = "black"),
    axis.text = element_text(color = "orange"),
    axis.title = element_text(color = "#ff7518"),
    plot.title = element_text(color = "orange", face = "bold", size = 18, hjust = 0.5)
  ) +
  geom_line(color = "#ff7518") +
  geom_point(color = "#ffcc00")
```

```{r}
#| echo: false
#| fig-align: center
#| 
interp_graph <- timebins1 |>
  dplyr::filter(trial == 2)

# Graph interpolation
pup_g <- ggplot(interp_graph, aes(x = timebins, y = aggbaseline)) +
  geom_point() +
  geom_line(color = "orange", size = 1.2) +
  ggtitle("Pupil Dilation") +
  xlab("Time (ms)") +
  ylab("Pupil Size (mm)") +
  theme_bw() +
  theme(
    axis.title.y = element_text(size = 16, face = "bold"),
    axis.title.x = element_text(size = 16, face = "bold"),
    axis.text.x  = element_text(size = 12, face = "bold"),
    axis.text.y  = element_text(size = 12, face = "bold"),
    plot.title   = element_text(size = 18, face = "bold", hjust = 0.5)
  )

pup_g +
  theme(
    panel.background = element_rect(fill = "black"),
    plot.background = element_rect(fill = "black"),
    axis.text = element_text(color = "orange"),
    axis.title = element_text(color = "#ff7518"),
    plot.title = element_text(color = "orange", face = "bold", size = 18, hjust = 0.5)
  ) +
  geom_line(color = "#ff7518") +
  geom_point(color = "#ffcc00")
```
